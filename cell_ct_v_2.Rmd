---
title: "Finding the number of cells in a volume of the crust"
output: pdf_document
author: Drew
date: "31 Aug 2020"
---

```{r setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
theme_set(theme_bw())
```

We want to calculate the number of cells above the 122 C isotherm from the volcano to the trench in a volume of Costa Rican crust, which is 273 km in the along-trench dimension. 

## Depth of the 122 C isotherm
Karen extracted the isotherm data from Harris (2010). The isotherms are quite linear, so we'll create a spline for each one, and then linearly interpolate between the two. 

```{r isotherm, message=FALSE, warning=FALSE, fig.cap = "Predicted 122 C isotherm (black line) and observed 100 and 200 C isotherms."}
d <- readxl::read_xlsx("data/Harris 2010 isotherm paper.xlsx", sheet = "Sheet1") %>%
  filter(!is.na(x.km)) %>%
  mutate(temp = as.factor(temp),
         x.m = x.km * 1000,
         z.m = z.km * 1000)

# Now empirically fit a spline to each isotherm, and then calculate the 122 C isotherm as 22% of the way from teh 100 to the 200 isotherm
# make_loess <- function(x) loess(z.m ~ x.m, data = x)
# splines <- d %>%
#   group_by(temp) %>%
#   nest() %>%
#   map(data, make_loess) # wtf map(), why u no work?
x.m.max <- max(d$x.m)
my.span <- 0.175
spline_100 <- loess(z.m ~ x.m, data = d %>% filter(temp == "100"), span = my.span)
spline_200 <- loess(z.m ~ x.m, data = d %>% filter(temp == "200"), span = my.span) 

# Predict the spline values at every 1-m interval (which is overkill, but saves me multiplying by a constant)
grid <- data.frame(x.m = seq(from = 0, to = x.m.max, by = 1))
preds.100 <- predict(spline_100, newdata = grid)
preds.200 <- predict(spline_200, newdata = grid)
preds.122 <- preds.100 + 0.22*(preds.200 - preds.100)

d_pred <- data.frame(x.m = grid$x.m, z.pred.122 = preds.122)

# Note that this is kinda janky. THe proper thing to do would be to interpolate the contour lines
# for which there are several R packages (contoureR, gr.devices::contourLines) that might work
set.seed(2112)
spline.122 <- loess(z.pred.122 ~ x.m, data = d_pred %>% slice_sample(n = 200), span = 0.3)
z.pred.122.smooth <- predict(spline.122, newdata = grid)
d_pred <- d_pred %>% 
  mutate(z.pred.122.smooth = z.pred.122.smooth)

p_isotherms <- ggplot() +
  geom_point(data = d, aes(x=x.m, y=z.m, shape = temp)) + 
  geom_smooth(data = d, aes(x=x.m, y=z.m, linetype = temp), method = "loess", se=FALSE, span = 0.175, colour = "gray50") +
  #geom_line(data = d_pred, aes(x=x.m, y=z.pred.122), linetype = 2) +
  geom_line(data = d_pred, aes(x=x.m, y=z.pred.122.smooth), linetype = 2) +
  #geom_vline(xintercept = 80000, linetype =3) + 
  geom_rect(data = data.frame(xmin = -Inf, xmax = 80000, ymin = -Inf, ymax = Inf), aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = "black", alpha = 0.3) + 
  scale_x_continuous(name  = "distance from trench (x), m") +
  scale_y_reverse(name = "depth, m") 
print(p_isotherms)
```
We'll only integrate from 80 km to ~200 km, since that is the location of the coastline based on the location of earthquakes in Harris et al. 

Magnabosco gives the cell abundance as 

$$
\rho = 10^Az^B
$$
where $A$ and $B$ are empirically determined from log-transformed observations of cell density as a function of depth. 


The antiderivative of $\rho(z)$ is given by
$$
\int 10^Az^Bdz = \frac{10^Az^{B+1}}{B+1} + C
$$

Note that $0^{B+1} = 0$ for any $B$, so

$$
\begin{aligned}
c_{col}(z_{iso}) &= \int_0^{z_{iso}} 10^Az^B dz \\
&= \frac{10^Az_{iso}^{B+1}}{B+1}
\end{aligned}
$$

So we can write a function that will calculate $c_{col}$ as a function of $z_{iso}$ as shown below. This will analytically integrate a column of cells at each meter of volcano-to-trench distance. I've titled the A parameter from Magnabosco et al as `A.m` to remind us that it is in units of cells per m<sup>3</sup>, not cm<sup>3</sup>. Since the conversion factor from cells cm<sup>-3</sup> to cells m<sup>-3</sup> is $100\times100\times100=10^6$, we can simply add 6 to Magnabosco's A. B stays the same. 

```{r}
calc_c_col <- function(z.iso, A.m, B) {
  c.col <- 10^A.m*z.iso^(B+1) / (B+1)
  c.col
}
```

Then, I can numerically integrate (slightly ham-fistedly, but it'll be close enough) across the trench-to-arc distance by adding up one-meter-wide columns:

$$
c_{vol} = y \times \Sigma_{x=0}^{x=x_{max}}\frac{10^Az_{iso(x)}^{B+1}}{B+1}
$$
Multiplying by $y$ to account for the number of cells in a cross-sectional slice gives the number of cells in a volume.

I'll use the empirical spline defined above for $z_{iso(x)}$. We can quibble about what the correct shape should be; I made it go linearly from the end of the spline to $(0,0)$, i.e. to have the depth be zero at the volcano. We'll define the relevant paremeters first, and then do the calculation.

```{r}
# Parameters
A.m <- 8.16 + 6
B <- -0.94
y.m <- 273.427 * 1000 # along-trench width of the integration box
# Calculate c_col for each depth
d_pred <- d_pred %>%
  mutate(c.col = calc_c_col(z.iso = z.pred.122.smooth, A.m = A.m, B = B),
         c.cross.section = c.col * y.m) 
```

Finally just add up all the slices from 80 km onwards:

```{r}
n.cells <- sum(d_pred$c.cross.section[d_pred$x.m >= 80*1000], na.rm = TRUE) # the last half kilometer is NA - it doesn't matter numerically, but I don't know why off the top of my head
```

The predicted number of cells in the volume is `r formatC(n.cells, format = "e", digits = 2)`. Note that Magnabosco et al estimate about $2-6 \times10^{29}$ cells on Earth. 

## Gut checks

I know that a big fraction of the total cells are in the top 100 meters. Let's see what the number would be if we only calculate in the top 100 m, for the entire data set. 

$$
\begin{aligned}
c_{vol} &= y \times \Sigma_{x=0}^{x=x_{max}}\frac{10^Az_{iso(x)}^{B+1}}{B+1}
&=100 \textrm{km} \times 1000 \textrm{m km}^{-1} \times \frac{ 10^{14.16} \times100^{0.06}}{0.06}
\end{aligned}
$$
```{r}
c.est <- y.m*(10^14.16*(200-80)*1000)^0.06/0.06
```
This estimates `r formatC(c.est, format="e", digits =2)`, which is low by a factor of about `r formatC(c.est/n.cells, format = "e", digits = 2)`.

Just as one more check, here's a plot of how the fraction of cells in a 14-km column you get from integrating only to a certain depth limit:

```{r}
z <- 0:14000
c.col <- calc_c_col(z, A.m = A.m, B = B)
c.frac <- c.col / max(c.col, na.rm = TRUE)

dfc <- data.frame(z = z, c.frac = c.frac)
ggplot(dfc, aes(x = z, y = c.frac)) +
  geom_line() +
  scale_y_continuous(labels = scales::label_percent()) +
  xlab("max depth of integration, m") + 
  ylab("frac of cells measured")
```

At a depth of 100m, we should get `r formatC(dfc$c.frac[dfc$z == 100]*100, format="g", digits = 0)`% of the total cells, which is most of them.

